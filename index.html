<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>雙手啟動！雙球挑戰手捉遊戲</title>
  
  <!-- 讓 iPhone 也可以全螢幕、隱藏瀏覽器列 -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="mobile-web-app-capable" content="yes">
  
  <!-- PWA 必要：manifest.json -->
  <link rel="manifest" href="manifest.json">
  
  <!-- iOS 桌面圖示（192x192） -->
  <link rel="apple-touch-icon" href="icon-192.png">
  
  <!-- 各種尺寸圖示（給 Android & iOS） -->
  <link rel="icon" sizes="192x192" href="icon-192.png">
  <link rel="icon" sizes="512x512" href="icon-512.png">

  <style>
    body { margin:0; background:#000; overflow:hidden; font-family:Arial, sans-serif; }
    #container { position: relative; width: 100vw; height: 100vh; }
    #video, #canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; }
    #canvas { pointer-events: none; }

    #flipBtn {
      position: absolute;
      top: 20px; left: 20px;
      padding: 12px 20px;
      background: #00ff88;
      color: #000;
      border: none;
      border-radius: 50px;
      font-size: 16px;
      font-weight: bold;
      z-index: 100;
      cursor: pointer;
      box-shadow: 0 4px 15px rgba(0,0,0,0.3);
    }
    #flipBtn:hover { background: #00ffaa; }

    #ui {
      position: absolute;
      top: 20px; right: 20px;
      color: white;
      font-size: 36px;
      font-weight: bold;
      background: rgba(0,0,0,0.6);
      padding: 12px 30px;
      border-radius: 20px;
      z-index: 50;
      backdrop-filter: blur(8px);
    }

    #readyText {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: 32px;
      text-align: center;
      background: rgba(0,0,0,0.7);
      padding: 20px 40px;
      border-radius: 20px;
      z-index: 90;
      pointer-events: none;
    }
  </style>
</head>
<body>

<div id="container">
  <video id="video" autoplay playsinline muted></video>
  <canvas id="canvas"></canvas>
  <button id="flipBtn">鏡頭反轉：開</button>
  <div id="ui" style="display:none;">分數：<span id="score">0</span></div>
  <div id="readyText">請用<br><b>任意兩手同時觸碰兩個紅球</b><br>即可啟動遊戲！</div>
</div>

<!-- MediaPipe -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>

<script>
  // 你的原始遊戲程式碼完全不變（我只補了 PWA 必要功能）
  const video = document.getElementById('video');
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const flipBtn = document.getElementById('flipBtn');
  const ui = document.getElementById('ui');
  const scoreEl = document.getElementById('score');
  const readyText = document.getElementById('readyText');

  let canvasWidth = window.innerWidth;
  let canvasHeight = window.innerHeight;
  canvas.width = canvasWidth;
  canvas.height = canvasHeight;

  let isMirrored = false;
  let gameStarted = false;
  let score = 0;

  let startLeftX = canvasWidth * 0.25;
  let startRightX = canvasWidth * 0.75;
  const startBalls = [
    { x: startLeftX, y: canvasHeight / 2, radius: 90, touched: false },
    { x: startRightX, y: canvasHeight / 2, radius: 90, touched: false }
  ];

  let targets = [];
  let isDoubleMode = false;

  const pose = new Pose({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`});
  pose.setOptions({
    modelComplexity: 1,
    smoothLandmarks: true,
    minDetectionConfidence: 0.5,
    minTrackingConfidence: 0.5
  });
  pose.onResults(onResults);

  const camera = new Camera(video, {
    onFrame: async () => {
      await pose.send({image: video});
    },
    width: 1280,
    height: 720
  });
  camera.start();

  flipBtn.addEventListener('click', () => {
    isMirrored = !isMirrored;
    flipBtn.textContent = `鏡頭反轉：${isMirrored ? '開' : '關'}`;
    flipBtn.style.background = isMirrored ? '#00ff88' : 'rgba(255,255,255,0.9)';
  });

  function getDisplayX(rawX) {
    return isMirrored ? canvasWidth - rawX : rawX;
  }

  function checkHandTouch(landmarks, ballX, ballY) {
    const fingers = [15,17,19,16,18,20];
    for (let i of fingers) {
      const p = landmarks[i];
      if (!p || p.visibility < 0.3) continue;
      const px = getDisplayX(p.x * canvasWidth);
      const py = p.y * canvasHeight;
      if (Math.hypot(px - ballX, py - ballY) < 120) {
        return true;
      }
    }
    return false;
  }

  function checkSingleTouch(landmarks) {
    if (targets.length !== 1) return false;
    return checkHandTouch(landmarks, targets[0].displayX, targets[0].y);
  }

  function spawnTargets() {
    targets = [];
    if (Math.random() < 0.3) {
      isDoubleMode = true;
      const ball1 = { x: 120 + Math.random() * (canvasWidth * 0.3), y: 120 + Math.random() * (canvasHeight - 240), displayX: 0, radius: 75, active: true, touched: false };
      const ball2 = { x: canvasWidth * 0.6 + Math.random() * (canvasWidth * 0.3), y: 120 + Math.random() * (canvasHeight - 240), displayX: 0, radius: 75, active: true, touched: false };
      ball1.displayX = getDisplayX(ball1.x);
      ball2.displayX = getDisplayX(ball2.x);
      targets.push(ball1, ball2);
    } else {
      isDoubleMode = false;
      const ball = { x: 80 + Math.random() * (canvasWidth - 160), y: 80 + Math.random() * (canvasHeight - 160), displayX: 0, radius: 80, active: true, touched: false };
      ball.displayX = getDisplayX(ball.x);
      targets.push(ball);
    }
  }

  function onResults(results) {
    ctx.save();
    ctx.clearRect(0, 0, canvasWidth, canvasHeight);

    if (isMirrored) {
      ctx.scale(-1, 1);
      ctx.drawImage(results.image, -canvasWidth, 0, canvasWidth, canvasHeight);
      ctx.setTransform(1, 0, 0, 1, 0, 0);
    } else {
      ctx.drawImage(results.image, 0, 0, canvasWidth, canvasHeight);
    }

    if (results.poseLandmarks) {
      const lm = results.poseLandmarks;
      const displayLandmarks = isMirrored ? lm.map(p => ({...p, x: 1 - p.x})) : lm;
      drawConnectors(ctx, displayLandmarks, POSE_CONNECTIONS, {color: '#00FFFF', lineWidth: 3});
      drawLandmarks(ctx, displayLandmarks, {color: '#FF00FF', radius: 5});

      if (!gameStarted) {
        const touch1 = checkHandTouch(lm, startBalls[0].x, startBalls[0].y);
        const touch2 = checkHandTouch(lm, startBalls[1].x, startBalls[1].y);
        startBalls[0].touched = touch1;
        startBalls[1].touched = touch2;

        startBalls.forEach(ball => {
          const dx = getDisplayX(ball.x);
          ctx.fillStyle = ball.touched ? '#ff00ff' : '#ff4444';
          ctx.shadowBlur = 30;
          ctx.shadowColor = ball.touched ? '#ff00ff' : '#ff0000';
          ctx.beginPath();
          ctx.arc(dx, ball.y, ball.radius, 0, Math.PI * 2);
          ctx.fill();
          ctx.shadowBlur = 0;
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 8;
          ctx.stroke();
        });

        if (touch1 && touch2) {
          gameStarted = true;
          readyText.style.display = 'none';
          ui.style.display = 'block';
          score = 0;
          scoreEl.textContent = '0';
          spawnTargets();
        }
      } else {
        let scored = false;
        if (isDoubleMode) {
          const t1 = checkHandTouch(lm, targets[0].displayX, targets[0].y);
          const t2 = checkHandTouch(lm, targets[1].displayX, targets[1].y);
          targets[0].touched = t1;
          targets[1].touched = t2;
          if (t1 && t2) { score += 2; scored = true; }
        } else if (checkSingleTouch(lm)) {
          targets[0].touched = true;
          score += 1;
          scored = true;
        }

        if (scored) {
          scoreEl.textContent = score;
          spawnTargets();
          scoreEl.style.transform = 'scale(2) rotate(360deg)';
          scoreEl.style.color = isDoubleMode ? '#ffd700' : '#00ff88';
          const add = isDoubleMode ? 2 : 1;
          scoreEl.innerHTML = `+${add}!`;
          setTimeout(() => {
            scoreEl.innerHTML = score;
            scoreEl.style.transform = 'scale(1)';
            scoreEl.style.color = 'white';
          }, 500);
        }

        targets.forEach((ball, i) => {
          if (!ball.active) return;
          const isYellow = isDoubleMode;
          const main = isYellow ? (ball.touched ? '#ffff99' : '#ffff00') : '#00ff00';
          const glow = isYellow ? (ball.touched ? '#ffff00' : '#ffd700') : '#00ff00';
          const border = isYellow ? '#ffaa00' : '#00ff88';

          ctx.fillStyle = main;
          ctx.shadowBlur = 60;
          ctx.shadowColor = glow;
          ctx.beginPath();
          ctx.arc(ball.displayX, ball.y, ball.radius, 0, Math.PI * 2);
          ctx.fill();
          ctx.lineWidth = 18;
          ctx.strokeStyle = border;
          ctx.stroke();
          ctx.shadowBlur = 0;

          const pulse = Math.sin(Date.now() * 0.015 + i) * 8 + ball.radius;
          ctx.beginPath();
          ctx.arc(ball.displayX, ball.y, pulse, 0, Math.PI * 2);
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 4;
          ctx.stroke();

          if (isYellow) {
            ctx.fillStyle = '#ff0000';
            ctx.font = 'bold 28px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('雙', ball.displayX, ball.y);
          }
        });
      }
    }
    ctx.restore();
  }

  window.addEventListener('resize', () => {
    canvasWidth = window.innerWidth;
    canvasHeight = window.innerHeight;
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;
    startLeftX = canvasWidth * 0.25;
    startRightX = canvasWidth * 0.75;
    startBalls[0].x = startLeftX;
    startBalls[1].x = startRightX;
    startBalls[0].y = canvasHeight / 2;
    startBalls[1].y = canvasHeight / 2;
    if (gameStarted) spawnTargets();
  });
</script>

</body>
</html>